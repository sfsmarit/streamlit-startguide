import streamlit as st

nl = "  "

st.set_page_config(page_title="はじめに")
st.title("Python + Streamlit で業務 Web アプリを作る方法")


st.subheader("目的", divider=True)
st.markdown(
    f"""
    IT エンジニア以外の人が、繰り返し行う業務を効率化するアプリを自ら開発し、チームに共有できるようになることを目指します。{nl}
    """
)


st.subheader("Web アプリの特徴", divider=True)
st.markdown(
    f"""
    :white_check_mark: **メリット**
    - 開発側
      - 配布、更新が簡単
      - 一元管理しやすい (ユーザーに改造されない)
    - ユーザー
      - 使うための技術的ハードルが低い
      - 環境依存が少ない (ブラウザがあれば使える)
    
    :no_entry: **デメリット**
    - マクロやスクリプトより開発コストが大きい
    - アプリを動作させるサーバが必要
    - セキュリティ上の制約がある (ファイルアクセスが限定的)
    
    > Web アプリは、チームの業務を標準化する手段として有効です。{nl}
    > 一方で、大量のローカルデータを処理するなどの用途には適していません。
    """
)


st.subheader("Streamlit とは", divider=True)
st.markdown(
    """
    Streamlit とは、Python で簡単に Web アプリを作れるオープンソースフレームワークです。
    データ分析結果を迅速に可視化することを目的に、2018年に設立され、翌年にオープンソース化されました。
    
    :white_check_mark: **メリット**
    - Python だけで作ることができる
        - フロントエンド(HTML, CSS, JavaScript 等) の知識不要
        - データ分析の勉強にもなる
    - 開発が速い
        - 少量のコードで UI を作れる
        - コード変更がリアルタイムで反映される
        - プリセットの UI が豊富で、見た目もよい
    - データの可視化に強い
        - グラフ表示: Matplotlib, Plotly
        - 表データ処理: Pandas
        - 機械学習のデモ

    :no_entry: **デメリット**
    - 複雑な UI を作りづらい
    - 大規模アプリに不向き
    - パフォーマンスに限界がある

    > Streamlit は「小規模アプリを速く作る」ことに特化したライブラリと言えます。
    """
)


st.subheader("どんなアプリに向いているか", divider=True)
st.markdown(
    f"""
    :white_check_mark: **おすすめ**
    - チームや部署内でのみ使用する
    - 小規模
    - 大量同時アクセスや、重いデータ処理をしない
    - 頻繁にカスタマイズしたい
    - プロトタイプ製作
    
    :no_entry: **他の手段を検討すべき**
    - 複数部署で使用する／自分しか使わない
    - 大規模・多機能
    - 高負荷
    - 社内の重要システム
    - ローカルファイルにアクセスする
    - 開発や運用に IT の専門知識が必要

    > 技術的・職務的に難しい場合は IT チームに相談してください。
    """
)


st.subheader("開発の流れ", divider=True)
st.markdown(
    """
    1. 開発環境を構築する
    2. ローカル環境でアプリを作る
    3. サーバにデプロイしてアプリを共有する
    
    詳細については次のページで説明しています。
    """
)


st.subheader("予備知識", divider=True)
st.markdown("ここから先は興味があれば読んでみてください。")

st.markdown("---")

st.markdown("##### 一般的な Web アプリの仕組み")
st.markdown(
    f"""

    1. **クライアント／サーバ**{nl}
    クライアントはユーザーが操作するブラウザなどで、画面を表示し入力を送信します。
    サーバはアプリケーションを動かすコンピュータで、社内サーバやクラウド上にあり、ブラウザから送られたリクエストを受け取り、処理した結果を返します。

    2. **HTTP リクエスト／レスポンス**{nl}
    ブラウザがURLにアクセスすると、まずHTTPリクエストが送信されます。
    これは GET や POST などのメソッドを使ってデータを要求する仕組みです。
    サーバはそのリクエストを処理し、 HTML や JSON、画像などを含む HTTP レスポンスを返します。
    ページ移動やボタン操作は、このリクエストとレスポンスの往復で成り立っています。

    3. **フロントエンド／バックエンド**{nl}
    フロントエンドは画面を作る部分で、HTML, CSS, JavaScriptなどを使ってUIを構築します。
    バックエンドはロジックやデータ処理を担当し、Python やデータベースへのアクセス、業務ルールの実装などを行います。
    一般的な Web アプリではフロントエンドとバックエンドを分離して異なる言語で実装しますが、Streamlit では Python だけで UI も生成します。

    4. **ルーティング**{nl}
    通常の Web アプリでは、/home や /items/123 のような URL に応じて表示内容を切り替えます。
    Streamlitでは、`st.Page`や`st.navigation`を使ってページ切り替えを実現します。

    5. **状態管理**{nl}
    フォームの入力値や一時的な設定、ログイン状態などの「状態」を保持する仕組みが必要です。
    一般的な Web アプリでは JavaScript や Cookie、localStorage などを使いますが、Streamlit では`st.session_state`という辞書を使って値を保持します。

    6. **データベース**{nl}
    アプリで扱うデータは、単純な構造であれば CSV や JSON などの静的ファイルに保存できます。
    より複雑なデータや検索・更新が頻繁に必要な場合は、SQLite や MariaDB などのデータベースを利用します。
    データベースを使うことで、効率的な検索や複数ユーザーからの同時アクセスにも対応できます。

    ---
    
    ##### Streamlit が大規模アプリに向いていない理由
    
    1. **再実行モデルによる負荷**{nl}
    Streamlit ではユーザーが操作するたびにスクリプト全体が再実行されます。大規模アプリでは再実行コストが高く、応答速度が低下します。
    ただし、キャッシュ`st.cache_data`や部分再実行`st.fragment`などの機能を活用することで改善が期待されます。
    
    2. **複雑な状態管理**{nl}
    ページ間や多数のユーザーで状態を保持する仕組みは`st.session_state`に依存します。
    アプリが大規模になると、UI 部品の数が増えて状態管理が複雑化するため、`key`の衝突を防ぐ仕組みが必要になります。
    さらに、高度な認証や権限管理を実現するには、追加の設計や外部サービスとの連携が不可欠です。

    3. **コード量の増加**{nl}
    Streamlit では、フロントエンド (UI) とバックエンド (処理) をどちらも Python で実装するため、コードが一つのファイルに集中して肥大化しやすいです。
    この問題を防ぐには、プロジェクト構成を整理し、UI／ロジック／データアクセスなどの責務を分離することが重要です。

    4. **スケーラビリティの限界**{nl}
    Streamlit は単一プロセスで動作し、同時接続数が増えると CPU・メモリ負荷が急増します。大規模利用にはロードバランサやコンテナ分散が必要です。

    5. **カスタマイズの制約**{nl}
    Streamlit は Python だけで簡単に UI を作ることを重視しており、複雑なレイアウトや動的 UI は不得意です。React や Vue のようなフロントエンドフレームワークほど自由度はありません。

    > 大規模アプリにおいても、Streamlit による開発が不可能というわけではありません。
    > しかし、Streamlit の拡張性やパフォーマンスの制約から、他の一般的な Web 開発手法のほうが望ましい場合が多いです。
    """
)
